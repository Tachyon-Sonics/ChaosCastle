DEFINITION MODULE Memory;

 FROM SYSTEM IMPORT ADDRESS, WORD, CAST;


 CONST
  tagDone = 0;
  tagIgnore = 1;
  tagMore = 2;
  tagSkip = 3;
  tagUser = MIN(INTEGER);

  NO = ORD(FALSE);
  YES = ORD(TRUE);


 TYPE
  SET16 = SET OF [0 ..15];
  CARD8 = SHORTCARD;
  INT8 = SHORTINT;
  CARD16 = CARDINAL;
  INT16 = INTEGER;
  CARD32 = LONGCARD;
  INT32 = LONGINT;
  REAL32 = REAL;
  REAL64 = LONGREAL;
  TagItem = RECORD
   tag: INT32;
   CASE x:INTEGER OF
     0: data: CARD32;
    |1: lint: INT32;
    |2: addr: ADDRESS;
    |3: hset, bset: SET16;
   END;
  END;
  TagItemPtr = POINTER TO TagItem;

  StrPtr = POINTER TO CHAR;

  NodePtr = POINTER TO Node;
  Node = RECORD
   next, prev: NodePtr;
   data: ADDRESS;
  END;
  List = RECORD
   head, tail: Node;
  END;
  ListPtr = POINTER TO List;

  MemHandler = PROCEDURE(): BOOLEAN;

 VAR
  multiThread: BOOLEAN;
  isMsb: BOOLEAN;


 PROCEDURE AllocMem(size{R.D2}: CARD32): ADDRESS;

 PROCEDURE AllocShared(size{R.D2}: CARD32): ADDRESS;

  (* May not return FALSE if wait = TRUE. If there is not enough memory,
   * a fallback global locking system is used.
   *)
 PROCEDURE LockMem(base: ADDRESS; offset, length: CARD32;
                   modify, wait: BOOLEAN): BOOLEAN;

 PROCEDURE UnlockMem(base: ADDRESS; offset, length: CARD32);

 PROCEDURE TryLock(base: ADDRESS; modify: BOOLEAN): BOOLEAN;

 PROCEDURE LockR(base: ADDRESS);

 PROCEDURE LockW(base: ADDRESS);

 PROCEDURE Unlock(base: ADDRESS);

 PROCEDURE AddMemHandler(Handler: MemHandler);

 PROCEDURE RemMemHandler(Handler: MemHandler);

 PROCEDURE FreeMem(VAR ptr{R.A2}: ADDRESS);

(*
 PROCEDURE TAG1(t1{R.D2}, v1{R.D3}: LONGINT): ADDRESS;
 PROCEDURE TAG2(t1{R.D2}, v1{R.D3}, t2{R.D4}, v2{R.D5}: LONGINT): ADDRESS;
 PROCEDURE TAG3(t1{R.D2}, v1{R.D3}, t2{R.D4}, v2{R.D5}, t3{R.D6}, v3{R.A2}: LONGINT): ADDRESS;
 PROCEDURE TAG4(t1, v1, t2, v2, t3, v3, t4, v4: LONGINT): ADDRESS;
 PROCEDURE TAG5(t1, v1, t2, v2, t3, v3, t4, v4, t5, v5: LONGINT): ADDRESS;
 PROCEDURE TAG6(t1, v1, t2, v2, t3, v3, t4, v4, t5, v5, t6, v6: LONGINT): ADDRESS;
 PROCEDURE TAG7(t1, v1, t2, v2, t3, v3, t4, v4, t5, v5, t6, v6, t7, v7: LONGINT): ADDRESS;
 PROCEDURE TAG8(t1, v1, t2, v2, t3, v3, t4, v4, t5, v5, t6, v6, t7, v7, t8, v8: LONGINT): ADDRESS;
*)

 PROCEDURE TAG1(t1: INT32; v1: ADDRESS): ADDRESS;
 PROCEDURE TAG2(t1: INT32; v1: ADDRESS; t2: INT32; v2: ADDRESS): ADDRESS;
 PROCEDURE TAG3(t1: INT32; v1: ADDRESS; t2: INT32; v2: ADDRESS; t3: INT32; v3: ADDRESS): ADDRESS;
 PROCEDURE TAG4(t1: INT32; v1: ADDRESS; t2: INT32; v2: ADDRESS; t3: INT32; v3: ADDRESS; t4: INT32; v4: ADDRESS): ADDRESS;
 PROCEDURE TAG5(t1: INT32; v1: ADDRESS; t2: INT32; v2: ADDRESS; t3: INT32; v3: ADDRESS; t4: INT32; v4: ADDRESS; t5: INT32; v5: ADDRESS): ADDRESS;
 PROCEDURE TAG6(t1: INT32; v1: ADDRESS; t2: INT32; v2: ADDRESS; t3: INT32; v3: ADDRESS; t4: INT32; v4: ADDRESS; t5: INT32; v5: ADDRESS; t6: INT32; v6: ADDRESS): ADDRESS;
 PROCEDURE TAG7(t1: INT32; v1: ADDRESS; t2: INT32; v2: ADDRESS; t3: INT32; v3: ADDRESS; t4: INT32; v4: ADDRESS; t5: INT32; v5: ADDRESS; t6: INT32; v6: ADDRESS; t7: INT32; v7: ADDRESS): ADDRESS;
 PROCEDURE TAG8(t1: INT32; v1: ADDRESS; t2: INT32; v2: ADDRESS; t3: INT32; v3: ADDRESS; t4: INT32; v4: ADDRESS; t5: INT32; v5: ADDRESS; t6: INT32; v6: ADDRESS; t7: INT32; v7: ADDRESS; t8: INT32; v8: ADDRESS): ADDRESS;

 PROCEDURE NextTag(VAR tags{R.A0}: TagItemPtr): TagItemPtr;


 PROCEDURE StrLength(str{R.A0}: StrPtr): CARD16;

 PROCEDURE CopyStr(src{R.A0}, dst{R.A1}: StrPtr; maxLength{R.D0}: CARD16);

 PROCEDURE ADS(str: ARRAY OF CHAR): ADDRESS;


 PROCEDURE InitList(VAR list{R.A0}: List);

 PROCEDURE First(VAR list{R.A0}: List): ADDRESS;

 PROCEDURE Last(VAR list{R.A0}: List): ADDRESS;

 PROCEDURE Head(VAR list{R.D0}: List): ADDRESS;

 PROCEDURE Tail(VAR list{R.A0}: List): ADDRESS;

 PROCEDURE Empty(VAR list{R.A0}: List): BOOLEAN;

 PROCEDURE Prev(VAR node{R.A1}: Node): ADDRESS;

 PROCEDURE Next(VAR node{R.A1}: Node): ADDRESS;

 PROCEDURE AddHead(VAR list{R.A0}: List; VAR node{R.A1}: Node);

 PROCEDURE AddTail(VAR list{R.A0}: List; VAR node{R.A1}: Node);

 PROCEDURE AddBefore(VAR before{R.A0}, node{R.A1}: Node);

 PROCEDURE Remove(VAR node{R.A1}: Node);


 PROCEDURE sReadInt8(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): INT8;
 PROCEDURE sWriteInt8(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32; value{R.D0}: INT8);

 PROCEDURE sReadMInt16(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): INT16;
 PROCEDURE sWriteMInt16(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32; value{R.D0}: INT16);
 PROCEDURE sReadLInt16(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): INT16;
 PROCEDURE sWriteLInt16(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32; value{R.D0}: INT16);

 PROCEDURE sReadMInt32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): INT32;
 PROCEDURE sWriteMInt32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32; value{R.D0}: INT32);
 PROCEDURE sReadLInt32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): INT32;
 PROCEDURE sWriteLInt32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32; value{R.D0}: INT32);

 PROCEDURE sReadMReal32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): REAL32;
 PROCEDURE sWriteMReal32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32; value{R.D0}: REAL32);
 PROCEDURE sReadLReal32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): REAL32;
 PROCEDURE sWriteLReal32(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32; value{R.D0}: REAL32);

 PROCEDURE sReadMReal64(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): REAL64;
 PROCEDURE sWriteMReal64(buffer{R.A0}: ADDRESS; offset{R.D2}: CARD32; value{R.D0}: REAL64);
 PROCEDURE sReadLReal64(buffer{R.A0}: ADDRESS; offset{R.D1}: CARD32): REAL64;
 PROCEDURE sWriteLReal64(buffer{R.A0}: ADDRESS; offset{R.D2}: CARD32; value{R.D0}: REAL64);

 PROCEDURE GetBitField(src{R.A0}: ADDRESS; offset{R.D1}: CARD32; size{R.D2}: CARD8): CARD8;

 PROCEDURE SetBitField(dst{R.A0}: ADDRESS; offset{R.D1}: CARD32; size{R.D2}: CARD8; data{R.D0}: CARD8);


END Memory.
